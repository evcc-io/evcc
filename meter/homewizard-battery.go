package meter

import (
	"fmt"

	"github.com/evcc-io/evcc/api"
	battery "github.com/evcc-io/evcc/meter/homewizard-battery"
	"github.com/evcc-io/evcc/util"
)

func init() {
	registry.Add("homewizard-battery", NewHomeWizardBatteryFromConfig)
}

type HomeWizardBattery struct {
	p1MeterAPI   *battery.API
	batteryAPIs  []*battery.API
	batteryCount int
}

func NewHomeWizardBatteryFromConfig(other map[string]any) (api.Meter, error) {
	cc := struct {
		Host      string
		Token     string
		Batteries []struct {
			Host  string
			Token string
		}
	}{}

	if err := util.DecodeOther(other, &cc); err != nil {
		return nil, err
	}

	// Basic validation - trust the config generated by 'evcc token homewizard'
	if cc.Host == "" || cc.Token == "" {
		return nil, fmt.Errorf("missing host or token - run 'evcc token homewizard'")
	}

	m := &HomeWizardBattery{
		p1MeterAPI: battery.NewAPI(cc.Host, cc.Token),
	}

	// Initialize battery APIs
	for _, bat := range cc.Batteries {
		m.batteryAPIs = append(m.batteryAPIs, battery.NewAPI(bat.Host, bat.Token))
	}

	m.batteryCount = len(m.batteryAPIs)

	if m.batteryCount > 0 {
		util.NewLogger("homewizard-battery").INFO.Printf("configured %d battery device(s)", m.batteryCount)
	}

	return m, nil
}

// CurrentPower implements the api.Meter interface
func (m *HomeWizardBattery) CurrentPower() (float64, error) {
	// Get combined battery power from P1 meter
	batteries, err := m.p1MeterAPI.GetBatteries()
	if err != nil {
		return 0, err
	}
	// Invert the battery power, because HW reports negative = discharging and positive = charging
	return -1 * batteries.PowerW, nil
}

var _ api.Battery = (*HomeWizardBattery)(nil)

// Soc implements the api.Battery interface
func (m *HomeWizardBattery) Soc() (float64, error) {
	// If no batteries are configured, return 0
	if len(m.batteryAPIs) == 0 {
		return 0, nil
	}

	// Fetch SoC from all batteries in parallel
	type result struct {
		soc float64
		err error
		idx int
	}

	results := make(chan result, len(m.batteryAPIs))

	for i, batteryAPI := range m.batteryAPIs {
		go func(idx int, api *battery.API) {
			data, err := api.GetMeasurement()
			if err != nil {
				results <- result{err: err, idx: idx}
				return
			}
			results <- result{soc: data.StateOfChargePct, idx: idx}
		}(i, batteryAPI)
	}

	// Collect results
	totalSoc := 0.0
	successCount := 0
	log := util.NewLogger("homewizard-battery")

	for i := 0; i < len(m.batteryAPIs); i++ {
		res := <-results
		if res.err != nil {
			log.ERROR.Printf("failed to get SoC from battery %d: %v", res.idx+1, res.err)
			continue
		}
		totalSoc += res.soc
		successCount++
	}

	if successCount == 0 {
		return 0, fmt.Errorf("failed to get SoC from any battery")
	}

	return totalSoc / float64(successCount), nil
}

var _ api.BatteryCapacity = (*HomeWizardBattery)(nil)

// Capacity implements the api.BatteryCapacity interface
func (m *HomeWizardBattery) Capacity() float64 {
	const batteryCapacity = 2.47 // kWh - HWE-BAT capacity
	return batteryCapacity * float64(m.batteryCount)
}

var _ api.BatteryController = (*HomeWizardBattery)(nil)

// SetBatteryMode implements the api.BatteryController interface
func (m *HomeWizardBattery) SetBatteryMode(mode api.BatteryMode) error {
	// Battery mode is controlled through the P1 meter
	return m.p1MeterAPI.SetBatteryMode(mode)
}
