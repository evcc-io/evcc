package meter

import (
	"fmt"
	"time"

	"github.com/evcc-io/evcc/api"
	battery "github.com/evcc-io/evcc/meter/homewizard-battery"
	"github.com/evcc-io/evcc/util"
)

func init() {
	registry.Add("homewizard-battery", NewHomeWizardBatteryFromConfig)
}

type HomeWizardBattery struct {
	p1MeterAPI   *battery.API
	batteryAPIs  []*battery.API
	batteryCount int
	capacity     float64 // optional user-provided capacity in kWh
	statusG      util.Cacheable[battery.Status]
	socG         util.Cacheable[float64]
}

func NewHomeWizardBatteryFromConfig(other map[string]any) (api.Meter, error) {
	cc := struct {
		Host      string
		Token     string
		Capacity  float64 // optional capacity in kWh
		Cache     time.Duration
		Batteries []struct {
			Host  string
			Token string
		}
	}{
		Cache: time.Second,
	}

	if err := util.DecodeOther(other, &cc); err != nil {
		return nil, err
	}

	// Basic validation - trust the config generated by 'evcc token homewizard'
	if cc.Host == "" || cc.Token == "" {
		return nil, fmt.Errorf("missing host or token - run 'evcc token homewizard'")
	}

	m := &HomeWizardBattery{
		p1MeterAPI: battery.NewAPI(cc.Host, cc.Token),
		capacity:   cc.Capacity,
	}

	// Initialize battery APIs
	for _, bat := range cc.Batteries {
		m.batteryAPIs = append(m.batteryAPIs, battery.NewAPI(bat.Host, bat.Token))
	}

	m.batteryCount = len(m.batteryAPIs)

	// Require at least one battery for this meter type
	if m.batteryCount == 0 {
		return nil, fmt.Errorf("no batteries configured - homewizard-battery requires at least one battery")
	}

	// Cache battery status (power from P1 meter)
	m.statusG = util.ResettableCached(func() (battery.Status, error) {
		return m.p1MeterAPI.GetBatteries()
	}, cc.Cache)

	// Cache SoC (averaged from all batteries)
	m.socG = util.ResettableCached(func() (float64, error) {
		type result struct {
			soc float64
			err error
			idx int
		}

		results := make(chan result, len(m.batteryAPIs))

		// Fetch SoC from all batteries in parallel
		for i, batteryAPI := range m.batteryAPIs {
			go func(idx int, api *battery.API) {
				data, err := api.GetMeasurement()
				if err != nil {
					results <- result{err: err, idx: idx}
					return
				}
				results <- result{soc: data.StateOfChargePct, idx: idx}
			}(i, batteryAPI)
		}

		// Collect results
		totalSoc := 0.0
		successCount := 0
		log := util.NewLogger("homewizard-battery")

		for range len(m.batteryAPIs) {
			res := <-results
			if res.err != nil {
				log.ERROR.Printf("failed to get SoC from battery %d: %v", res.idx+1, res.err)
				continue
			}
			totalSoc += res.soc
			successCount++
		}

		if successCount == 0 {
			return 0, fmt.Errorf("failed to get SoC from any battery")
		}

		return totalSoc / float64(successCount), nil
	}, cc.Cache)

	util.NewLogger("homewizard-battery").INFO.Printf("configured %d battery device(s)", m.batteryCount)

	return m, nil
}

// CurrentPower implements the api.Meter interface
func (m *HomeWizardBattery) CurrentPower() (float64, error) {
	status, err := m.statusG.Get()
	if err != nil {
		return 0, err
	}
	// Invert the battery power, because HW reports negative = discharging and positive = charging
	return -1 * status.PowerW, nil
}

var _ api.Battery = (*HomeWizardBattery)(nil)

// Soc implements the api.Battery interface
func (m *HomeWizardBattery) Soc() (float64, error) {
	return m.socG.Get()
}

var _ api.BatteryCapacity = (*HomeWizardBattery)(nil)

// Capacity implements the api.BatteryCapacity interface
func (m *HomeWizardBattery) Capacity() float64 {
	// If user provided capacity, use that
	if m.capacity > 0 {
		return m.capacity
	}

	// Otherwise calculate based on battery count (each HWE-BAT is 2.47 kWh)
	const batteryCapacity = 2.47 // kWh - HWE-BAT capacity
	return batteryCapacity * float64(m.batteryCount)
}

var _ api.BatteryController = (*HomeWizardBattery)(nil)

// SetBatteryMode implements the api.BatteryController interface
func (m *HomeWizardBattery) SetBatteryMode(mode api.BatteryMode) error {
	// Battery mode is controlled through the P1 meter
	if err := m.p1MeterAPI.SetBatteryMode(mode); err != nil {
		return err
	}

	// Reset cache after mode change
	m.statusG.Reset()

	return nil
}
